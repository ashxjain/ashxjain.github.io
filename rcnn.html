
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="" />

  <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Source+Sans+Pro:300,400,400i,700" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="http://ashxjain.github.io/theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="http://ashxjain.github.io/theme/pygments/github.min.css">
  <link rel="stylesheet" type="text/css" href="http://ashxjain.github.io/theme/font-awesome/css/font-awesome.min.css">


    <link href="http://ashxjain.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="ashxjain Atom">





<meta name="author" content="Ashish Jain" />
<meta name="description" content="Understanding RCNN models" />
<meta name="keywords" content="ml, rcnn">

<meta property="og:site_name" content="ashxjain"/>
<meta property="og:title" content="RCNN Family"/>
<meta property="og:description" content="Understanding RCNN models"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="http://ashxjain.github.io/rcnn.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2020-12-06 00:00:00+05:30"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="http://ashxjain.github.io/author/ashish-jain.html">
<meta property="article:section" content="ml"/>
<meta property="article:tag" content="ml"/>
<meta property="article:tag" content="rcnn"/>
<meta property="og:image" content="/images/sitelogo.png?s=120">

  <title>ashxjain &ndash; RCNN Family</title>

</head>
<body>
  <aside>
    <div>
      <a href="http://ashxjain.github.io">
        <img src="/images/sitelogo.png?s=120" alt="Ashish Jain" title="Ashish Jain">
      </a>
      <h1><a href="http://ashxjain.github.io">Ashish Jain</a></h1>

<p>Software Engineer</p>

      <ul class="social">
        <li><a class="sc-linkedin" href="https://linkedin.com/in/ashxjain" target="_blank"><i class="fa fa-linkedin"></i></a></li>
        <li><a class="sc-github" href="https://github.com/ashxjain" target="_blank"><i class="fa fa-github"></i></a></li>
        <li><a class="sc-twitter" href="https://twitter.com/ashxjain" target="_blank"><i class="fa fa-twitter"></i></a></li>
      </ul>
    </div>


  </aside>
  <main>


<article class="single">
  <header>
      
    <h1 id="rcnn">RCNN Family</h1>
    <p>
          Posted on Sun 06 December 2020 in <a href="http://ashxjain.github.io/category/ml.html">ml</a>


    </p>
  </header>


  <div>
    <p>Understanding RCNN models and its variants</p>
<ul>
<li>
<p>The story of RCNN actually starts from this paper: <a href="https://ivi.fnwi.uva.nl/isis/publications/2013/UijlingsIJCV2013/UijlingsIJCV2013.pdf">Selective Search for Object Recognition. </a>SSOR addresses the problem of generating possible object locations for use in object recognition. In turn, SSOR depends on <a href="http://people.cs.uchicago.edu/~pff/papers/seg-ijcv.pdf">Efficient Graph-based Image Segmentation</a> to find it's first proposals. This uses Computer Vision and not AI for segmentation, basically splitting the color channels</p>
</li>
<li>
<p><strong>RCNN</strong>: Manually segmented images into multiple region proposals (using CV algorithms) and then passed each proposal through AlexNET and then merge the segmented images. So for each image, AlexNET was run 2000 times! Also, The selective search algorithm is a fixed algorithm. Therefore, no learning
  is happening at that stage. This could lead to the generation of bad candidate region proposals.<img src="images/RCNNInitial.png" alt="RCNNInitial" style="zoom: 33%;" /></p>
</li>
<li>
<p><strong>Fast RCNN</strong>: Optimized RCNN by not passing Region proposals to AlexNet 2000 times, but rather just one time. Here we just have to figure out to map proposed region to convolved output
  <img src="images/FastRCNN.png" alt="FastRCNN" style="zoom: 33%;" />
  <img src="images/FastRCNNArch.png" alt="FastRCNNArch" style="zoom:33%;" /></p>
</li>
<li>
<p>The network first processes the whole image with several convolutional (conv) and max pooling layers to produce a conv feature map.</p>
</li>
<li>
<p>Then, for each object proposal a region of interest (RoI) pooling layer extracts a fixed-length feature vector from the feature map (7x7). This is done because later we are converting 2D to 1D (FC layers) and 1D expects fixed size of input. Hence we convert the conv ROI input to fixed dim 7x7.</p>
</li>
<li>
<p>Each feature vector is fed into a sequence of fully connected (fc) layers that finally branch into two sibling output layers:</p>
<ul>
<li>one that produces softmax probability estimates over K object classes plus a catch-all “background” class and</li>
<li>another layer that outputs four real-valued numbers for each of the K object classes. Each set of 4 values encodes refined bounding-box positions for one of the K classes.</li>
<li>The <strong>RoI</strong> Pooling layer uses maxpooling to convert the features inside any valid region of interest into a small feature map with resolution of 7x7. 
<img src="images/FastRCNNArch2.png" alt="FastRCNNArch2" style="zoom: 33%;" /></li>
</ul>
</li>
<li>
<p>So, above we see that input image is fed to conv net and then we get ROI from the proposal method (in this case it is SSOR), ROI pooling is done to make feature maps of resolution 7x7. Then FCs predicts two outputs. One is the class prediction and another one is the adjustments. Adjustments are nothing but adjustments to be done to original proposal.</p>
</li>
<li>
<p>ROI Pooling: Divide the ROI in such a way that we get final dimensions and then max pool in those divided blocks
    <img src="images/ROI1.png" alt="ROI1" style="zoom: 25%;" /> <img src="images/ROI2.png" alt="ROI2" style="zoom:25%;" />
  <img src="images/ROI3.png" alt="ROI3" style="zoom:25%;" /> <img src="images/ROI4.png" alt="ROI4" style="zoom:25%;" />
    <img src="images/ROI5.png" alt="ROI5" style="zoom:25%;" /></p>
</li>
<li>
<p>To increase resolution to 7x7 say from 4x3, then we just to interpolation i.e. 4x3 -&gt; interpolated to -&gt; 8x6, but we because we need 7x7, just repeat last column to get 8x7, then perform ROI pooling</p>
</li>
<li>Above shows one example of a region proposal made by SSOR. But actual bounding boxes are not always well alligned, like shown below. Proposed bbox might be the dotted lines. This scaled to the closest edge and then we get well aligned bbox. Obviously this introduces more errors and that will be solved later
    <img alt="ROIMisAlign" src="images/ROIMisAlign.png"></li>
<li>
<p>Also, above division of boxes can be done the way we like i.e. first box is 2x3, it could've been 3x3, etc. Fix the method and then train the model</p>
</li>
<li>
<p><strong>Faster RCNN</strong>:</p>
</li>
<li>
<p>Fast RCNN uses SSOR (internally uses EGIS), which has its problems, here it is fixed by using a neural network to predict these region proposals. This is RPN (Region Proposal Network)</p>
</li>
<li>
<p>So the network will predict classes and since the network has learnt in its layers Edges/Gradients/Textures/Patterns, same can be used for RPN. Hence we branch out the network to predict RPs and then merge it back after few convolutions to get classes &amp; boxes</p>
</li>
<li>
<p>Here RPN itself can predict the class as it knows the object. So RPN's output is the region proposal and the objectness. Infact it doesn't just say if the obj is present or not. It gives two output:</p>
<table>
<thead>
<tr>
<th>Foreground (object)</th>
<th>Background (object's background)</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>Ignore</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>Allow</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>Allow</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>Punish!</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>RPN:</p>
<ul>
<li>First the picture goes through conv layers and feature maps are extracted</li>
<li>Then a sliding window is used in RPN for each location over the feature map. Here sliding window means going through each block of final conv i.e. say in Yolo we had 13x13 divisions, so going through each block from 169 blocks (13x13) is called sliding window. In YoloV2, we only go through on network, but here it is different. Here we first get objectness (i.e. Fb/Bg), x,y,h,w (region proposal bbox, not final bbox). Then through another network we get classes &amp; final bbox</li>
<li>Unlike YoloV2 where our final feature map is 13x13, here it is based on input size. But we stop at the scale of 16 i.e. if input size is 1024, then our final feature map size will be 64x64.</li>
<li>Here in the feature maps we'll have 9 anchor boxes per block. In YoloV2, we had 5 anchor boxes. Also anchor boxes are not found using K-means, instead they have fixed anchor boxes</li>
<li>For each location, 9 anchor boxes are used (3 scales of 128, 256 and 512, and 3 aspect ratios of 1:1, 1:2 and 2:1) for generating region proposals. This means we have the following anchor boxes:
    | Scales | Aspect Ratios | Anchor box |
| ------ | ----- | ------------- |
| 128 | 1:1 | 128x128 |
|  | 2:1 | 256x128 |
| | 1:2 | 128x256 |
| 256 | 1:1 | 256x256 |
|  | 2:1 | 512x256 |
| | 1:2 | 256x512 |
| 512 | 1:1 | 512x512 |
|  | 2:1 | 1024x512 |
| | 1:2 | 512x1024 |</li>
<li>A <strong>cls</strong> layer outputs <strong>2x</strong>9 scores whether is object or not for 9 anchors. </li>
<li>A <strong>reg</strong> layer outputs 4x9 scores for coordinates for 9 anchor boxes.</li>
<li>So if we compare YoloV2 with this network, we can understand this better:
    |  | YoloV2 | RPN |
| ------ | ----- | ------------- |
| Anchor Boxes | 5 | 9 |
| Technique to find anchor box | KMeans | Ratios |
| Prediction Output | Objectness (1value per anchor box) | Objectness (2[fg/bg] per anchor box) |
|| x,y,h,w (4 values per anchor box) | Dx,Dy,Dh,Dw (4 values per anchor box), this is region proposals (not final box). It is deltas and not actual value. So Dx,Dy is how much anchor box center. Dh,Dw is how much of anchor box to crop |
|| class predictions | no class predictions |</li>
<li>With a size of WxH feature map, there are WH9 anchors in total. This means, we can have W != H.</li>
<li>We then feed the region proposals to the RoI layer of the Fast R-CNN.
  <img alt="RCNNRPN" src="images/RCNNRPN.png"></li>
<li>Faster RCNN (or others) have three main types of networks:</li>
<li>Head (say ResNet50 etc)</li>
<li>Region Proposal Network</li>
<li>Classification Network</li>
<li>Software flow:
  <img src="images/FasterRCNNFlow.png" alt="FasterRCNNFlow" style="zoom: 67%;" /></li>
<li><strong>Anchor Generation Layer:</strong> This layer generates a fixed number of “anchors” (bounding boxes) by first generating 9 anchors of different scales and aspect ratios and then replicating these anchors by translating them across uniformly spaced grid points spanning the input image.</li>
<li><strong>Proposal Layer:</strong> Transform the anchors according to the bounding box regression coefficients to generate transformed anchors. Then prune the number of anchors by applying non-maximum suppression (see Appendix) using the probability of an anchor being a foreground region</li>
<li><strong>Anchor Target Layer</strong>: The goal of the anchor target layer is to produce a set of “good” anchors and the corresponding foreground/background labels and target regression coefficients to train the Region Proposal Network. The output of this layer is only used to train the RPN network and is not used by the classification layer. Given a set of anchors (produced by the anchor generation layer, the anchor target layer identifies promising foreground and background anchors. Promising foreground anchors are those whose overlap with some ground truth box is higher than a threshold. Background boxes are those whose overlap with any ground truth box is lower than a threshold. The anchor target layer also outputs a set of bounding box regressors i.e., a measure of how far each anchor target is from the closest bounding box. These regressors only make sense for the foreground boxes as there is no notion of “closest bounding box” for a background box.</li>
<li><strong>RPN Loss:</strong> The RPN loss function is the metric that is minimized during optimization to train the RPN network. The loss function is a combination of:</li>
<li>The proportion of bounding boxes produced by RPN that are correctly classified as foreground/background</li>
<li>Some distance measure between the predicted and target regression coefficients.</li>
<li><strong>Proposal Target Layer:</strong> The goal of the proposal target layer is to prune the list of anchors produced by the proposal layer and produce <em>class specific</em> bounding box regression targets that can be used to train the classification layer to produce good class labels and regression targets</li>
<li><strong>ROI Pooling Layer:</strong> Implements a spatial transformation network that samples the input feature map given the bounding box coordinates of the region proposals produced by the proposal target layer. These coordinates will generally not lie on integer boundaries, thus interpolation based sampling is required.</li>
<li><strong>Classification Layer:</strong> The classification layer takes the output feature maps produced by the ROI Pooling Layer and passes them through a series of convolutional layers. The output is fed through two fully connected layers. The first layer produces the class probability distribution for each region proposal and the second layer produces a set of class specific bounding box regressors.</li>
<li><strong>Classification Loss:</strong> Similar to RPN loss, classification loss is the metric that is minimized during optimization to train the classification network. During back propagation, the error gradients flow to the RPN network as well, so training the classification layer modifies the weights of the RPN network as well. We’ll have more to say about this point later. The classification loss is a combination of:</li>
<li>The proportion of bounding boxes produced by RPN that are correctly classified (as the correct object class)</li>
<li>Some distance measure between the predicted and target regression coefficients.</li>
<li>We saw above in our comparison table that we predict delta values. Why? We can that by understanding what <strong>Anchor Generation Layer</strong> does</li>
<li>The anchor generation layer produces a set of bounding boxes (called “anchor boxes”) of varying sizes and aspect ratios spread all over the input image. These bounding boxes are the same for all images i.e., they are agnostic of the content of an image. Some of these bounding boxes will enclose foreground objects while most won’t. The goal of the RPN network is to learn to identify which of these boxes are good boxes – i.e., likely to contain a foreground object and to produce target regression coefficients, which when applied to an anchor box turns the anchor box into a better bounding box (fits the enclosed foreground object more closely).</li>
<li>Our objective is to find bounding boxes in the image. These have rectangular shape and can come in different sizes and aspect ratios. Imagine we were trying to solve the problem knowing beforehand that there are two objects on the image. The first idea that comes to mind is to train a network that returns 8 values: <strong>two xmin, ymin, xmax, ymax</strong>
    <strong>​​tuples</strong> defining a bounding box for each object.</li>
<li>This approach has some fundamental problems. For example, images may have different sizes and aspect ratios, having a good model trained to predict raw coordinates can turn out to be very complicated (if not impossible). Another problem is invalid predictions: when predicting xmin and xmax we have to somehow enforce that xmin &lt; xmax.</li>
<li>It turns out that there is a simpler approach to predicting bounding boxes by learning to predict offsets from reference boxes. We take a reference box xcenter, ycenter, width, height and learn to predict Δ x_center, Δy_center, Δwidth, Δheight  , which are usually small values that tweak the reference box to better fit what we want.</li>
<li>The diagram below demonstrates how these anchor boxes are generated.</li>
<li>The region proposal layer has two goals:</li>
<li>From a list of anchors, identify background and foreground anchors</li>
<li>Modify the position, width and height of the anchors by applying a set of “regression coefficients” to <strong>improve the quality of the anchors</strong> (for example, make them fit the boundaries of objects better)</li>
<li>The region proposal layer consists of a Region Proposal <em>Network</em> and three layers:<ul>
<li>Proposal Layer</li>
<li>Anchor Target Layer and</li>
<li>Proposal Target Layer.</li>
</ul>
</li>
<li>RPN Diagram:
  <img src="images/RPN.png" alt="RPN" style="zoom: 400%;" /></li>
</ul>
</li>
<li>
<p>Details about each layer &amp; loss:</p>
<ul>
<li>The region proposal layer runs feature maps produced by the head network through a convolutional layer (called rpn_net in code) followed by RELU. The output of rpn_net is run through two (1,1) kernel convolutional layers to produce background/foreground class scores and probabilities and corresponding bounding box regression coefficients. The stride length of the head network matches the stride used while generating the anchors, so the number of anchor boxes are in 1-1 correspondence with the information produced by the region proposal network</li>
<li>(number of anchor boxes = number of class scores = number of bounding box regression coefficients = <img alt="\frac{w}{16}\times\frac{h}{16}\times9" src="http://www.telesens.co/wp-content/ql-cache/quicklatex.com-cafeb41929226bc13d570966070b1313_l3.svg">)</li>
<li>The proposal layer takes the anchor boxes produced by the anchor generation layer and prunes the number of boxes by applying non-maximum suppression based on the foreground scores (see appendix for details). It also generates transformed bounding boxes by applying the regression coefficients generated by the RPN to the corresponding anchor boxes.</li>
<li>The goal of the anchor target layer is to select promising anchors that can be used to train the RPN network to:</li>
<li>distinguish between foreground and background regions and</li>
<li>generate good bounding box regression coefficients for the foreground boxes.</li>
<li>It is useful to first look at how the RPN Loss is calculated. This will reveal the information needed to calculate the RPN loss which makes it easy to follow the operation of the Anchor Target Layer. To do generate good bboxes from a set of anchor boxes, the RPN layer must learn to classify an anchor box as background or foreground and calculate the regression coefficients to modify the position, width and height of a foreground anchor box to make it a “better” foreground box (fit a foreground object more closely). RPN Loss is formulated in such a way to encourage the network to learn this behaviour.</li>
<li>RPN loss is a sum of the classification loss and bounding box regression loss. The classification loss uses cross entropy loss to penalize incorrectly classified boxes and the regression loss uses a function of the distance between the true regression coefficients (calculated using the closest matching ground truth box for a foreground anchor box) and the regression coefficients predicted by the network (see rpn_bbx_pred_net in the RPN network architecture diagram).</li>
<li>The feature vector is then passed through two fully connected layers – bbox_pred_net and cls_score_net. The cls_score_net layer produces the class scores for each bounding box (which can be converted into probabilities by applying softmax). The bbox_pred_net layer produces the class specific bounding box regression coefficients which are combined with the original bounding box coordinates produced by the proposal target layer to produce the final bounding boxes.</li>
</ul>
</li>
<li>
<p>In Summary:
    <img src="images/FastRCNNSummary.png" alt="FastRCNNSummary" style="zoom:150%;" /></p>
<ul>
<li>Faster R-CNN uses a CNN feature extractor to extract image features. Then it uses a CNN region proposal network to create region of interests (RoIs). We apply RoI pooling to warp them into fixed dimension. It is then feed into fully connected layers to make classification and boundary box prediction.</li>
</ul>
</li>
<li>
<p><strong>Mask R-CNN</strong></p>
</li>
<li>
<p>The Faster R-CNN builds all the ground works for feature extractions and ROI proposals. At first sight, performing image segmentation may require more detail analysis to colorize the image segments. By surprise, not only we can piggyback on this model, the extra work required is pretty simple. After the ROI pooling, we add 2 more convolution layers to build the mask.
    <img src="images/MaskRCNN.png" alt="MaskRCNN" style="zoom:150%;" /></p>
</li>
<li>
<p>Example conv flow: Say input is 7x7x2048 and we need mask as 7x7x3 (say we have 3 classes), then we can just have two convs of 3x3x512 &amp; 3x3x3. So mask output is divided into fixed blocks (like YoloV2), and mask of each class is a separate dim. So if there are 15 classes, then the output will be 7x7x15</p>
</li>
<li>
<p>Infact we can even add another branch like how we did for mask to predict pose.</p>
</li>
<li>
<p>ROI Align:</p>
<ul>
<li>
<p>Another major contribution of Mask R-CNN is the refinement of the ROI pooling. In ROI, the warping is digitalized (top left diagram below): the cell boundaries of the target feature map are forced to realign with the boundary of the input feature maps.</p>
</li>
<li>
<p>Therefore, each target cells may not be in the same size (bottom left diagram). Mask R-CNN uses <strong>ROI Align</strong> which does not digitalize the boundary of the cells (top right) and make every target cell to have the same size (bottom right).</p>
</li>
<li>
<p>It also applies interpolation to calculate the feature map values within the cell better. For example, by applying interpolation, the maximum feature value on the top left is changed from 0.8 to 0.88 now.</p>
</li>
</ul>
<p><img alt="ROIAlign" src="images/ROIAlign.png"></p>
<ul>
<li>
<p>A detailed explanation on ROI pooling can be found <a href="https://towardsdatascience.com/understanding-region-of-interest-part-2-roi-align-and-roi-warp-f795196fc193">here</a></p>
</li>
<li>
<p>ROI Align makes significant improvements in the accuracy</p>
</li>
</ul>
</li>
</ul>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="http://ashxjain.github.io/tag/ml.html">ml</a>
      <a href="http://ashxjain.github.io/tag/rcnn.html">rcnn</a>
    </p>
  </div>





</article>

    <footer>
<p>&copy;  2018</p>
<p>    Powered by <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a>
</p>    </footer>
  </main>




<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " ashxjain ",
  "url" : "http://ashxjain.github.io",
  "image": "/images/sitelogo.png?s=120",
  "description": "Ashish Jain's Thoughts and Writings"
}
</script>

</body>
</html>